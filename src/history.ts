import fs from "fs/promises";
import path from "path";
import os from "os";
import { execFile } from "child_process";
import { createLogger } from "./utils/logger";
import { config } from "./config";
import { loadTerminals } from "./terminal-store";
import { getProject } from "./project-store";
import type { HistoryResult, TerminalBlock, SessionSummary } from "./types";

const log = createLogger("history");

interface SDKContentBlock {
  type: string;
  text?: string;
  id?: string;
  name?: string;
  input?: unknown;
  tool_use_id?: string;
  content?: string | Array<{ type: string; text?: string }>;
  is_error?: boolean;
  source?: {
    type: string;
    media_type?: string;
    data?: string;
  };
}

interface SDKMessage {
  type: string;
  subtype?: string;
  message?: {
    role: string;
    content: string | SDKContentBlock[];
    usage?: {
      input_tokens?: number;
      cache_creation_input_tokens?: number;
      cache_read_input_tokens?: number;
    };
  };
  timestamp?: number | string;
  session_id?: string;
}

type SDKMessageContent = string | SDKContentBlock[];

interface SessionMetadata {
  sessionId: string;
  createdAt: string;
  firstMessage: string | null;
  lastMessagePreview: string | null;
  tokenCount: number;
}

function getClaudeProjectsDir(): string {
  return path.join(os.homedir(), ".claude", "projects");
}

function projectPathToClaudeDir(projectPath: string): string {
  const resolved = path.resolve(projectPath);
  const folderName = resolved.replace(/[^a-zA-Z0-9]/g, "-");
  return path.join(getClaudeProjectsDir(), folderName);
}

async function findSessionFile(sessionId: string): Promise<string | null> {
  const claudeDir = getClaudeProjectsDir();

  try {
    const searchDir = async (dir: string): Promise<string | null> => {
      const entries = await fs.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);

        if (entry.isDirectory()) {
          const found = await searchDir(fullPath);
          if (found) return found;
        } else if (entry.isFile() && entry.name.endsWith(".jsonl")) {
          if (entry.name === `${sessionId}.jsonl`) {
            return fullPath;
          }
          try {
            const content = await fs.readFile(fullPath, "utf-8");
            if (
              content.includes(`\"sessionId\":\"${sessionId}\"`) ||
              content.includes(`\"session_id\":\"${sessionId}\"`)
            ) {
              return fullPath;
            }
          } catch (error) {
            log.warn({ error, fullPath }, "Failed to read session file during search");
          }
        }
      }

      return null;
    };

    return await searchDir(claudeDir);
  } catch (error) {
    log.warn({ error, claudeDir }, "Failed to search for session file");
    return null;
  }
}

// Filter out image metadata strings that Claude adds
function cleanImageMetadata(text: string): string {
  // Remove patterns like "[Image: original 1072x2008, displayed at 1068x2000. Multiply coordinates by 1.00 to map to original image.]"
  return text.replace(/\[Image: original \d+x\d+, displayed at \d+x\d+\. Multiply coordinates by [\d.]+ to map to original image\.\]\s*/g, "").trim();
}

// Check if message is a CLI command artifact we should skip
function isCliCommandArtifact(text: string): boolean {
  // Skip command XML tags
  if (text.includes("<command-name>") || text.includes("<command-message>")) return true;
  if (text.includes("<local-command-stdout>")) return true;
  if (text.includes("<command-args>")) return true;
  // Skip compaction caveat messages
  if (text.includes("Caveat: The messages below were generated by the user while running local commands")) return true;
  // Skip compaction summary preamble (it's a system message, not user)
  if (text.startsWith("This session is being continued from a previous conversation")) return true;
  // Skip "No response requested" post-compaction message
  if (text.trim() === "No response requested.") return true;
  return false;
}

// Check if assistant message content should be skipped
function isAssistantArtifact(text: string): boolean {
  if (text.trim() === "No response requested.") return true;
  return false;
}

function parseToolResultContent(content: SDKContentBlock["content"]): string {
  if (typeof content === "string") {
    return cleanImageMetadata(content);
  }
  if (Array.isArray(content)) {
    return cleanImageMetadata(
      content
        .filter(c => c.type === "text" && c.text)
        .map(c => c.text)
        .join("\n")
    );
  }
  return String(content || "");
}

function parseTimestamp(value: unknown): number | null {
  if (typeof value === "number" && Number.isFinite(value)) {
    return value;
  }
  if (typeof value === "string") {
    const parsed = Date.parse(value);
    if (!Number.isNaN(parsed)) {
      return parsed;
    }
  }
  return null;
}

function extractUserText(content: SDKMessageContent): string | null {
  if (typeof content === "string") {
    const cleaned = cleanImageMetadata(content);
    if (!cleaned || isCliCommandArtifact(cleaned)) {
      return null;
    }
    return cleaned;
  }

  if (Array.isArray(content)) {
    const textParts = content
      .filter((block) => block.type === "text" && block.text)
      .map((block) => cleanImageMetadata(block.text as string))
      .filter((text) => text && !isCliCommandArtifact(text));

    const joined = textParts.join("\n").trim();
    return joined ? joined : null;
  }

  return null;
}

function extractAssistantText(content: SDKMessageContent): string | null {
  if (typeof content === "string") {
    const cleaned = cleanImageMetadata(content);
    if (!cleaned || isAssistantArtifact(cleaned)) {
      return null;
    }
    return cleaned;
  }

  if (Array.isArray(content)) {
    const textParts = content
      .filter((block) => block.type === "text" && block.text)
      .map((block) => cleanImageMetadata(block.text as string))
      .filter((text) => text && !isAssistantArtifact(text));

    const joined = textParts.join("\n").trim();
    return joined ? joined : null;
  }

  return null;
}

async function readSessionMetadataFromFile(filePath: string, sessionId: string): Promise<SessionMetadata> {
  const fileContent = await fs.readFile(filePath, "utf-8");
  const lines = fileContent.split("\n").filter(Boolean);

  let firstMessage: string | null = null;
  let firstMessageTimestamp: number | null = null;
  let firstUserMessage: string | null = null;
  let firstUserTimestamp: number | null = null;
  let lastMessagePreview: string | null = null;
  let tokenCount = 0;

  for (const line of lines) {
    let msg: SDKMessage;
    try {
      msg = JSON.parse(line) as SDKMessage;
    } catch {
      continue;
    }

    const timestamp = parseTimestamp(msg.timestamp);

    if (msg.type === "assistant" && msg.message?.usage) {
      const usage = msg.message.usage;
      const totalTokens = (usage.input_tokens || 0) +
        (usage.cache_creation_input_tokens || 0) +
        (usage.cache_read_input_tokens || 0);
      if (totalTokens > 0) {
        tokenCount = totalTokens;
      }
    }

    if (msg.type === "user" && msg.message?.content) {
      const text = extractUserText(msg.message.content);
      if (text) {
        if (!firstUserMessage) {
          firstUserMessage = text;
          if (timestamp) {
            firstUserTimestamp = timestamp;
          }
        }
        if (!firstMessage) {
          firstMessage = text;
          if (timestamp) {
            firstMessageTimestamp = timestamp;
          }
        }
        lastMessagePreview = text;
      }
    }

    if (msg.type === "assistant" && msg.message?.content) {
      const text = extractAssistantText(msg.message.content);
      if (text) {
        if (!firstMessage) {
          firstMessage = text;
          if (timestamp) {
            firstMessageTimestamp = timestamp;
          }
        }
        lastMessagePreview = text;
      }
    }
  }

  const stat = await fs.stat(filePath);
  const fileTimestamp = Number.isFinite(stat.birthtimeMs) ? stat.birthtimeMs : stat.mtimeMs;
  const createdAtMs = firstUserTimestamp ?? firstMessageTimestamp ?? fileTimestamp;

  return {
    sessionId,
    createdAt: new Date(createdAtMs).toISOString(),
    firstMessage: firstUserMessage ?? firstMessage,
    lastMessagePreview,
    tokenCount,
  };
}

function hasMeaningfulMetadata(metadata: SessionMetadata): boolean {
  return Boolean(metadata.firstMessage || metadata.lastMessagePreview || metadata.tokenCount > 0);
}

async function moveToTrash(filePath: string): Promise<void> {
  await new Promise<void>((resolve, reject) => {
    execFile("trash", [filePath], (error) => {
      if (error) {
        reject(error);
        return;
      }
      resolve();
    });
  });
}

export async function listSessionsForProject(projectId: string): Promise<SessionSummary[]> {
  const project = await getProject(projectId);
  if (!project) {
    log.warn({ projectId }, "Project not found while listing sessions");
    return [];
  }

  const sessions = new Map<string, SessionSummary>();
  const terminals = await loadTerminals();
  const projectDir = projectPathToClaudeDir(project.path);
  const projectFiles = new Map<string, string>();

  try {
    const entries = await fs.readdir(projectDir, { withFileTypes: true });
    for (const entry of entries) {
      if (!entry.isFile() || !entry.name.endsWith(".jsonl")) {
        continue;
      }
      const sessionId = entry.name.replace(/\.jsonl$/, "");
      projectFiles.set(sessionId, path.join(projectDir, entry.name));
    }
  } catch (error) {
    const err = error as NodeJS.ErrnoException;
    if (err.code !== "ENOENT") {
      log.warn({ error: err, projectDir }, "Failed to scan Claude project directory");
    }
  }

  for (const terminal of terminals) {
    if (terminal.projectId !== projectId || !terminal.sessionId) {
      continue;
    }

    const sessionId = terminal.sessionId;
    const filePath = projectFiles.get(sessionId) || await findSessionFile(sessionId);
    let metadata: SessionMetadata | null = null;

    if (filePath) {
      try {
        metadata = await readSessionMetadataFromFile(filePath, sessionId);
      } catch (error) {
        log.warn({ error, filePath, sessionId }, "Failed to read session metadata");
      }
    }

    sessions.set(sessionId, {
      sessionId,
      projectId,
      createdAt: metadata?.createdAt ?? terminal.createdAt,
      lastMessagePreview: metadata?.lastMessagePreview ?? null,
      tokenCount: metadata?.tokenCount ?? 0,
      status: terminal.status,
    });
  }

  for (const [sessionId, filePath] of projectFiles.entries()) {
    if (sessions.has(sessionId)) {
      continue;
    }

    try {
      const metadata = await readSessionMetadataFromFile(filePath, sessionId);
      if (!hasMeaningfulMetadata(metadata)) {
        continue;
      }
      sessions.set(sessionId, {
        sessionId,
        projectId,
        createdAt: metadata.createdAt,
        lastMessagePreview: metadata.lastMessagePreview,
        tokenCount: metadata.tokenCount,
        status: "closed",
      });
    } catch (error) {
      log.warn({ error, filePath, sessionId }, "Failed to read session metadata");
    }
  }

  return Array.from(sessions.values()).sort((a, b) => {
    return Date.parse(b.createdAt) - Date.parse(a.createdAt);
  });
}

export async function deleteSession(sessionId: string): Promise<boolean> {
  const filePath = await findSessionFile(sessionId);
  if (!filePath) {
    return false;
  }

  await moveToTrash(filePath);
  log.info({ filePath, sessionId }, "Session file moved to trash");
  return true;
}

export async function getSessionMetadata(sessionId: string): Promise<SessionMetadata | null> {
  const filePath = await findSessionFile(sessionId);
  if (!filePath) {
    return null;
  }

  try {
    return await readSessionMetadataFromFile(filePath, sessionId);
  } catch (error) {
    log.warn({ error, filePath, sessionId }, "Failed to read session metadata");
    return null;
  }
}

/**
 * Load session history from Claude's JSONL files.
 * @param sessionId - Claude session ID
 * @param terminalId - Optional terminal ID for the blocks (defaults to sessionId prefix)
 */

export async function loadSessionHistory(
  sessionId: string,
  terminalId?: string
): Promise<HistoryResult> {
  const filePath = await findSessionFile(sessionId);

  if (!filePath) {
    log.info({ sessionId }, "No session file found");
    return { blocks: [], lastContextTokens: 0 };
  }

  log.info({ filePath, sessionId }, "Loading session history");

  // Use provided terminalId or derive from sessionId
  const blockTerminalId = terminalId || sessionId.slice(0, 8);

  try {
    const fileContent = await fs.readFile(filePath, "utf-8");
    const lines = fileContent.trim().split("\n").filter(Boolean);

    let blocks: TerminalBlock[] = [];
    let toolBlockMap = new Map<string, TerminalBlock>();
    let lastContextTokens = 0;
    let lastCompactionIndex = -1;

    // First pass: find the last compaction point and extract summary
    let compactionSummary: string | null = null;
    for (let i = 0; i < lines.length; i++) {
      try {
        const msg: SDKMessage = JSON.parse(lines[i]);
        // Check for compaction summary (starts new context)
        if (msg.type === "user" && msg.message?.role === "user") {
          const content = msg.message.content;
          if (typeof content === "string" &&
              content.startsWith("This session is being continued from a previous conversation")) {
            lastCompactionIndex = i;
            // Extract just the summary part (after the preamble)
            compactionSummary = content;
          }
        }
        // Also check for compact_boundary system message
        if (msg.type === "system" && (msg as { subtype?: string }).subtype === "compact_boundary") {
          lastCompactionIndex = i;
        }
      } catch {
        // Skip malformed lines
      }
    }

    // Start from after the last compaction (or from beginning if none)
    const startIndex = lastCompactionIndex >= 0 ? lastCompactionIndex + 1 : 0;
    log.info({ lastCompactionIndex, startIndex, totalLines: lines.length, hasSummary: !!compactionSummary }, "Found compaction point");

    // Add compaction summary as the first block if it exists
    if (compactionSummary) {
      blocks.push({
        id: crypto.randomUUID(),
        type: "summary",
        terminalId: blockTerminalId,
        timestamp: Date.now(),
        content: compactionSummary,
      });
    }

    for (let i = startIndex; i < lines.length; i++) {
      const line = lines[i];
      try {
        const msg: SDKMessage = JSON.parse(line);
        const timestamp = parseTimestamp(msg.timestamp) ?? Date.now();

        // Track token count from assistant messages (they have usage data)
        if (msg.type === "assistant" && msg.message?.usage) {
          const usage = msg.message.usage;
          const totalTokens = (usage.input_tokens || 0) +
            (usage.cache_creation_input_tokens || 0) +
            (usage.cache_read_input_tokens || 0);
          if (totalTokens > 0) {
            lastContextTokens = totalTokens;
          }
        }

        // User messages
        if (msg.type === "user" && msg.message?.role === "user") {
          const content = msg.message.content;

          // Handle string content (plain user message)
          if (typeof content === "string") {
            // Skip CLI command artifacts and compaction messages
            if (isCliCommandArtifact(content)) {
              continue;
            }
            const cleanedContent = cleanImageMetadata(content);
            if (cleanedContent) {
              blocks.push({
                id: crypto.randomUUID(),
                type: "user_command",
                terminalId: blockTerminalId,
                timestamp,
                content: cleanedContent,
              });
            }
            continue;
          }

          // Handle array content
          if (Array.isArray(content)) {
            // Check for tool results - attach to existing tool blocks
            const toolResults = content.filter(c => c.type === "tool_result");
            if (toolResults.length > 0) {
              for (const result of toolResults) {
                const toolBlock = toolBlockMap.get(result.tool_use_id || "");
                if (toolBlock) {
                  toolBlock.toolResult = parseToolResultContent(result.content);
                  toolBlock.toolError = result.is_error || false;
                }
              }
              continue; // Don't create a block for tool_result messages
            }

            // Regular user message with text/images
            const textParts = content
              .filter(c => c.type === "text" && c.text)
              .map(c => cleanImageMetadata(c.text as string))
              .filter(t => t && !isCliCommandArtifact(t)); // Remove empty strings and CLI artifacts

            const images = content.filter(c => c.type === "image" && c.source);

            // Only create block if there's actual content (not just image metadata)
            if (textParts.length > 0 || images.length > 0) {
              const cleanedText = textParts.join("\n");
              // Skip if only images but no text (image-only metadata messages)
              if (!cleanedText && images.length === 0) {
                continue;
              }
              blocks.push({
                id: crypto.randomUUID(),
                type: "user_command",
                terminalId: blockTerminalId,
                timestamp,
                content: cleanedText,
                attachments: images.length > 0 ? images.map(img => ({
                  type: "image" as const,
                  name: "image",
                  data: img.source?.data,
                  mimeType: img.source?.media_type || "image/png",
                })) : undefined,
              });
            }
          }
          continue;
        }

        // Assistant messages
        if (msg.type === "assistant" && msg.message?.content) {
          const content = msg.message.content;

          if (Array.isArray(content)) {
            for (const block of content) {
              if (block.type === "text" && block.text) {
                // Skip assistant artifacts like "No response requested."
                if (isAssistantArtifact(block.text)) {
                  continue;
                }
                const cleanedText = cleanImageMetadata(block.text);
                if (cleanedText) {  // Only add if there's content after cleaning
                  blocks.push({
                    id: crypto.randomUUID(),
                    type: "text",
                    terminalId: blockTerminalId,
                    timestamp,
                    content: cleanedText,
                  });
                }
              } else if (block.type === "tool_use" && block.id) {
                const toolBlock: TerminalBlock = {
                  id: crypto.randomUUID(),
                  type: "tool_use",
                  terminalId: blockTerminalId,
                  timestamp,
                  toolUseId: block.id,
                  toolName: block.name,
                  toolInput: block.input,
                };
                blocks.push(toolBlock);
                toolBlockMap.set(block.id, toolBlock);
              }
            }
          }
          continue;
        }

        // System init message
        if (msg.type === "system" && msg.subtype === "init") {
          blocks.push({
            id: crypto.randomUUID(),
            type: "system",
            terminalId: blockTerminalId,
            timestamp,
            content: `Session initialized: ${msg.session_id?.slice(0, 8)}...`,
          });
        }
      } catch {
        // Skip malformed lines
      }
    }

    const summaryBlock = blocks.find((block) => block.type === "summary");
    const contentBlocks = blocks.filter((block) => block.type !== "summary");
    const limitedContentBlocks = contentBlocks.slice(
      Math.max(0, contentBlocks.length - config.historyBlockLimit)
    );
    const finalBlocks = summaryBlock ? [summaryBlock, ...limitedContentBlocks] : limitedContentBlocks;

    log.info(
      { totalBlocks: finalBlocks.length, lastContextTokens, historyBlockLimit: config.historyBlockLimit },
      "Parsed history blocks (since last compaction)"
    );

    return { blocks: finalBlocks, lastContextTokens };
  } catch (error) {
    log.error({ error, filePath }, "Failed to load session history");
    return { blocks: [], lastContextTokens: 0 };
  }
}
